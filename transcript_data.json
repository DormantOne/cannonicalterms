<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Interactive Handwashing Song</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: auto;
            position: relative; /* For tooltip positioning */
        }

        h1 {
            color: #333;
            text-align: center;
        }

        .verse {
            margin-bottom: 20px;
        }

        .chorus {
            font-style: italic;
            margin-bottom: 20px;
            background-color: #f5f5f5;
            padding: 10px;
            border-left: 3px solid #0066cc;
        }

        .clickable {
            color: #0066cc;
            cursor: pointer;
            text-decoration: underline;
        }

        .tooltip {
            display: none;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            position: absolute;
            z-index: 10;
            max-width: 300px;
            box-shadow: 0px 0px 10px rgba(0,0,0,0.1);
        }

        .highlight {
            background-color: yellow;
        }
    </style>
</head>
<body>
    <h1>Interactive Handwashing Song</h1>

    <audio id="audio" controls>
        <source src="Clean_Canticle_2.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>

    <div id="lyrics"></div>
    <div id="tooltip" class="tooltip"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const audio = document.getElementById('audio');
            const tooltip = document.getElementById('tooltip');
            const lyricsContainer = document.getElementById('lyrics');

            // Dictionary for translations of known Latin lines
            const translations = {
                "Signa sequimur, veritatem quaerimus": "We follow the signs, we seek the truth",
                "Manus mundae, mens attenta": "Clean hands, attentive mind",
                "Sanitatis custodes sumus": "We are the guardians of health",
                "Tempus numeratum, rituale servatum": "Measured time, ritual preserved",
                "In ablutione, constantia": "In washing, steadfastness",
                "Instrumenta pura, cura secura": "Pure instruments, secure care",
                "In diligentia, excellentia": "In diligence, excellence",
                "Invisibilia vincimus scientia": "We conquer the invisible through science",
                "In persistentia, victoria": "In persistence, victory",
                "Vasa vacua, pericula vera": "Empty vessels, real dangers",
                "Repleatur sine mora": "Must be refilled without delay",
                "Mens intentiva, cura preventiva": "Attentive mind, preventive care",
                "In sapientia, prudentia": "In wisdom, prudence",
                "Signa dubia, protectio certa": "Uncertain signs, certain protection",
                "Melius praevenire quam poenitere": "Better to prevent than to regret",
                "Verba lenia, effectus magna": "Gentle words, great effects",
                "In harmonia, efficacia": "In harmony, effectiveness",
                "In purificatione est salus": "In purification there is salvation",
                "Per scientiam, absolutio": "Through knowledge, absolution",
                "Eternam vigilantiam": "Eternal vigilance",
                "Pro sanitate omnium": "For the health of all"
            };

            // Fetch the external JSON (ensure 'transcript_data.json' is correctly referenced)
            fetch('transcript_data.json')
                .then(response => response.json())
                .then(data => {
                    const transcript = data.transcript;
                    const wordsData = data.words;

                    // Extract recognized words and sort them by start time
                    const recognizedWords = wordsData
                        .filter(w => w.case === "success" && !isNaN(parseFloat(w.start)))
                        .sort((a, b) => parseFloat(a.start) - parseFloat(b.start));

                    // Initialize word pointer
                    let wordPointer = 0;

                    // Parse transcript into lines
                    const lines = transcript.split(/\r?\n/).filter(line => line.trim() !== '');

                    // Array to hold line elements with their start times
                    const lineElements = [];

                    lines.forEach((line, lineIndex) => {
                        // Clean line for matching (remove asterisks and punctuation)
                        const cleanLine = line.replace(/\*/g, '').replace(/[.,]/g, '').trim().toLowerCase();
                        const lineWords = cleanLine.split(/\s+/);

                        let earliestStart = null;

                        // Search for the first recognized word in the line starting from wordPointer
                        for (let i = wordPointer; i < recognizedWords.length; i++) {
                            const word = recognizedWords[i].word.toLowerCase();
                            if (lineWords.includes(word)) {
                                earliestStart = parseFloat(recognizedWords[i].start);
                                wordPointer = i + 1; // Move pointer past this word
                                break; // Assign only the earliest word
                            }
                        }

                        // If no recognized word is found in this line, skip highlighting
                        if (earliestStart === null) {
                            return; // Continue to next line
                        }

                        // Determine if the line is a chorus or verse
                        let isChorus = false;
                        let isLatin = false;
                        if (line.trim().startsWith('*')) {
                            isLatin = true;
                            // Identify chorus lines based on known patterns
                            if (
                                cleanLine.startsWith("signa sequimur") ||
                                cleanLine.startsWith("manus mundae") ||
                                cleanLine.startsWith("sanitatis custodes")
                            ) {
                                isChorus = true;
                            }
                        }

                        // Create HTML elements
                        const wrapper = document.createElement('div');
                        wrapper.classList.add(isChorus ? 'chorus' : 'verse');

                        const span = document.createElement('span');
                        span.textContent = line;
                        span.setAttribute('data-start', earliestStart);

                        if (isLatin) {
                            span.classList.add('clickable');
                            const originalLine = line.replace(/\*/g, '').trim();
                            if (translations[originalLine]) {
                                span.setAttribute('data-translation', translations[originalLine]);
                            } else {
                                span.setAttribute('data-translation', "No translation available");
                            }
                        }

                        wrapper.appendChild(span);
                        lyricsContainer.appendChild(wrapper);
                        lineElements.push(span);
                    });

                    // Sort the lineElements by their start times
                    const timedLines = lineElements
                        .map(el => ({
                            element: el,
                            startTime: parseFloat(el.getAttribute('data-start'))
                        }))
                        .sort((a, b) => a.startTime - b.startTime);

                    // Highlighting logic
                    let currentIndex = 0;
                    audio.addEventListener('timeupdate', () => {
                        const currentTime = audio.currentTime;

                        while (currentIndex < timedLines.length && currentTime >= timedLines[currentIndex].startTime) {
                            // Highlight current line
                            timedLines[currentIndex].element.classList.add('highlight');
                            timedLines[currentIndex].element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                            // Remove highlight from previous line
                            if (currentIndex > 0) {
                                timedLines[currentIndex - 1].element.classList.remove('highlight');
                            }

                            currentIndex++;
                        }
                    });

                    // Reset highlighting when audio is restarted
                    audio.addEventListener('seeked', () => {
                        const currentTime = audio.currentTime;
                        // Remove all highlights
                        timedLines.forEach(line => line.element.classList.remove('highlight'));
                        // Reset currentIndex
                        currentIndex = 0;
                        // Re-highlight lines based on the new currentTime
                        timedLines.forEach((line, index) => {
                            if (currentTime >= line.startTime) {
                                line.element.classList.add('highlight');
                                if (index > 0) {
                                    timedLines[index - 1].element.classList.remove('highlight');
                                }
                                currentIndex = index + 1;
                            }
                        });
                    });

                })
                .catch(error => {
                    console.error('Error fetching or parsing transcript_data.json:', error);
                });

            // Tooltip logic
            document.addEventListener('click', (event) => {
                if (event.target.classList.contains('clickable')) {
                    const translation = event.target.getAttribute('data-translation');
                    tooltip.textContent = translation;
                    tooltip.style.display = 'block';
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style.left = (rect.left + window.scrollX) + 'px';
                    tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            });

            // Hide tooltip when clicking outside
            document.addEventListener('click', (event) => {
                if (!event.target.classList.contains('clickable')) {
                    tooltip.style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
