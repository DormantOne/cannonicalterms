<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Interactive Handwashing Song</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: auto;
        }

        h1 {
            color: #333;
        }

        .verse {
            margin-bottom: 20px;
        }

        .chorus {
            font-style: italic;
            margin-bottom: 20px;
            background-color: #f5f5f5;
            padding: 10px;
            border-left: 3px solid #0066cc;
        }

        .clickable {
            color: #0066cc;
            cursor: pointer;
            text-decoration: underline;
        }

        .tooltip {
            display: none;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            position: absolute;
            z-index: 1;
            max-width: 300px;
        }

        .highlight {
            background-color: yellow;
        }
    </style>
</head>
<body>
    <h1>Interactive Handwashing Song</h1>

    <audio id="audio" controls>
        <source src="Clean_Canticle_2.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>

    <div id="lyrics"></div>
    <div id="tooltip" class="tooltip"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const audio = document.getElementById('audio');
            const tooltip = document.getElementById('tooltip');
            const lyricsContainer = document.getElementById('lyrics');

            // Hard-coded dictionary for translations of known Latin lines:
            const translations = {
                "Signa sequimur, veritatem quaerimus": "We follow the signs, we seek the truth",
                "Manus mundae, mens attenta": "Clean hands, attentive mind",
                "Sanitatis custodes sumus": "We are the guardians of health",
                "Tempus numeratum, rituale servatum": "Measured time, ritual preserved",
                "In ablutione, constantia": "In washing, steadfastness",
                "Instrumenta pura, cura secura": "Pure instruments, secure care",
                "In diligentia, excellentia": "In diligence, excellence",
                "Invisibilia vincimus scientia": "We conquer the invisible through science",
                "In persistentia, victoria": "In persistence, victory",
                "Vasa vacua, pericula vera": "Empty vessels, real dangers",
                "Repleatur sine mora": "Must be refilled without delay",
                "Mens intentiva, cura preventiva": "Attentive mind, preventive care",
                "In sapientia, prudentia": "In wisdom, prudence",
                "Signa dubia, protectio certa": "Uncertain signs, certain protection",
                "Melius praevenire quam poenitere": "Better to prevent than to regret",
                "Verba lenia, effectus magna": "Gentle words, great effects",
                "In harmonia, efficacia": "In harmony, effectiveness",
                "In purificatione est salus": "In purification there is salvation",
                "Per scientiam, absolutio": "Through knowledge, absolution",
                "Eternam vigilantiam": "Eternal vigilance",
                "Pro sanitate omnium": "For the health of all"
            };

            // fetch the external JSON
            fetch('transcript_data.json')
                .then(response => response.json())
                .then(data => {
                    const transcript = data.transcript;
                    const words = data.words;

                    // Parse transcript into lines
                    const lines = transcript.split('\r\n').filter(line => line.trim() !== '');

                    const lineElements = [];

                    // If you want to assign approximate times to lines with no recognized words, uncomment the following:
                    // let lastKnownStart = 0;
                    // let approximateIncrement = 2; // how many seconds to increment per unknown line

                    lines.forEach((line) => {
                        const lineWords = line.replace(/\*|\./g, '').split(/\s+/).map(w => w.toLowerCase());
                        let earliestStart = null;

                        // Find recognized words' earliest start time
                        words.forEach(wordObj => {
                            const w = wordObj.word.toLowerCase();
                            if (lineWords.includes(w) && wordObj.case === "success") {
                                const startTime = parseFloat(wordObj.start);
                                if (!isNaN(startTime)) {
                                    if (earliestStart === null || startTime < earliestStart) {
                                        earliestStart = startTime;
                                    }
                                }
                            }
                        });

                        // If no recognized word found, we skip highlighting by NOT setting data-start
                        // If you'd rather assign an approximate time, uncomment below:
                        // if (earliestStart === null) {
                        //     earliestStart = lastKnownStart + approximateIncrement;
                        // }
                        // if (earliestStart !== null) {
                        //     lastKnownStart = earliestStart;
                        // }

                        let isChorus = false;
                        let isLatin = false;
                        let cleanLine = line.replace(/\*/g, '').trim();
                        if (line.trim().startsWith('*')) {
                            isLatin = true;
                            if (cleanLine.startsWith("Signa sequimur") ||
                                cleanLine.startsWith("Manus mundae") ||
                                cleanLine.startsWith("Sanitatis custodes")) {
                                isChorus = true;
                            }
                        }

                        const wrapper = document.createElement('div');
                        wrapper.classList.add(isChorus ? 'chorus' : 'verse');

                        const span = document.createElement('span');
                        span.textContent = line;

                        // Only set data-start if earliestStart is found or assigned
                        if (earliestStart !== null) {
                            span.setAttribute('data-start', earliestStart);
                        }

                        if (isLatin) {
                            span.classList.add('clickable');
                            if (translations[cleanLine]) {
                                span.setAttribute('data-translation', translations[cleanLine]);
                            } else {
                                span.setAttribute('data-translation', "No translation available");
                            }
                        }

                        wrapper.appendChild(span);
                        lyricsContainer.appendChild(wrapper);
                        lineElements.push(span);
                    });

                    // Highlighting logic
                    let currentIndex = 0;
                    audio.addEventListener('timeupdate', () => {
                        const currentTime = audio.currentTime;
                        while (currentIndex < lineElements.length) {
                            const startAttr = lineElements[currentIndex].getAttribute('data-start');
                            if (startAttr !== null && currentTime >= parseFloat(startAttr)) {
                                lineElements[currentIndex].classList.add('highlight');
                                lineElements[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                                if (currentIndex > 0) {
                                    lineElements[currentIndex - 1].classList.remove('highlight');
                                }
                                currentIndex++;
                            } else {
                                break;
                            }
                        }
                    });
                });

            // Tooltip logic
            document.addEventListener('click', (event) => {
                if (event.target.classList.contains('clickable')) {
                    const translation = event.target.getAttribute('data-translation');
                    tooltip.textContent = translation;
                    tooltip.style.display = 'block';
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style.left = rect.left + window.scrollX + 'px';
                    tooltip.style.top = rect.bottom + window.scrollY + 5 + 'px';
                } else if (tooltip.style.display === 'block') {
                    tooltip.style.display = 'none';
                }
            });

        });
    </script>
</body>
</html>
