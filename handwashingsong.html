<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Interactive Handwashing Song</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: auto;
        }

        h1 {
            color: #333;
        }

        .verse {
            margin-bottom: 20px;
        }

        .chorus {
            font-style: italic;
            margin-bottom: 20px;
            background-color: #f5f5f5;
            padding: 10px;
            border-left: 3px solid #0066cc;
        }

        .clickable {
            color: #0066cc;
            cursor: pointer;
            text-decoration: underline;
        }

        .tooltip {
            display: none;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            position: absolute;
            z-index: 1;
            max-width: 300px;
        }

        .highlight {
            background-color: yellow;
        }
    </style>
</head>
<body>
<h1>Interactive Handwashing Song</h1>

<audio id="audio" controls>
    <source src="Clean_Canticle_2.mp3" type="audio/mp3">
    Your browser does not support the audio element.
</audio>

<div id="lyrics"></div>
<div id="tooltip" class="tooltip"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const audio = document.getElementById('audio');
    const tooltip = document.getElementById('tooltip');
    const lyricsContainer = document.getElementById('lyrics');

    const translations = {
        "Signa sequimur, veritatem quaerimus": "We follow the signs, we seek the truth",
        "Manus mundae, mens attenta": "Clean hands, attentive mind",
        "Sanitatis custodes sumus": "We are the guardians of health",
        "Tempus numeratum, rituale servatum": "Measured time, ritual preserved",
        "In ablutione, constantia": "In washing, steadfastness",
        "Instrumenta pura, cura secura": "Pure instruments, secure care",
        "In diligentia, excellentia": "In diligence, excellence",
        "Invisibilia vincimus scientia": "We conquer the invisible through science",
        "In persistentia, victoria": "In persistence, victory",
        "Vasa vacua, pericula vera": "Empty vessels, real dangers",
        "Repleatur sine mora": "Must be refilled without delay",
        "Mens intentiva, cura preventiva": "Attentive mind, preventive care",
        "In sapientia, prudentia": "In wisdom, prudence",
        "Signa dubia, protectio certa": "Uncertain signs, certain protection",
        "Melius praevenire quam poenitere": "Better to prevent than to regret",
        "Verba lenia, effectus magna": "Gentle words, great effects",
        "In harmonia, efficacia": "In harmony, effectiveness",
        "In purificatione est salus": "In purification there is salvation",
        "Per scientiam, absolutio": "Through knowledge, absolution",
        "Eternam vigilantiam": "Eternal vigilance",
        "Pro sanitate omnium": "For the health of all"
    };

    // Replace 'transcript_data.json' with the actual URL/path to your JSON file
    fetch('transcript_data.json')
        .then(response => response.json())
        .then(data => {
            const transcript = data.transcript;
            const wordsData = data.words;

            // Create a map of recognized words to their start times (multiple occurrences possible)
            // We will just store them as array of {word, start} sorted by start time.
            const recognizedWords = wordsData
                .filter(w => w.case === "success" && !isNaN(parseFloat(w.start)))
                .map(w => ({word: w.word.toLowerCase(), start: parseFloat(w.start)}));

            // Parse transcript lines
            const lines = transcript.split('\r\n').filter(line => line.trim() !== '');

            const lineElements = [];

            lines.forEach((line) => {
                const lineWords = line.replace(/\*|\./g, '').split(/\s+/).map(w => w.toLowerCase());
                let earliestStart = null;

                // Find all recognized words that appear in this line and track the earliest start
                recognizedWords.forEach(rw => {
                    if (lineWords.includes(rw.word)) {
                        if (earliestStart === null || rw.start < earliestStart) {
                            earliestStart = rw.start;
                        }
                    }
                });

                let isChorus = false;
                let isLatin = false;
                let cleanLine = line.replace(/\*/g, '').trim();
                if (line.trim().startsWith('*')) {
                    isLatin = true;
                    if (cleanLine.startsWith("Signa sequimur") ||
                        cleanLine.startsWith("Manus mundae") ||
                        cleanLine.startsWith("Sanitatis custodes")) {
                        isChorus = true;
                    }
                }

                const wrapper = document.createElement('div');
                wrapper.classList.add(isChorus ? 'chorus' : 'verse');

                const span = document.createElement('span');
                span.textContent = line;

                // Only set data-start if we have an earliestStart
                if (earliestStart !== null) {
                    span.setAttribute('data-start', earliestStart);
                }

                if (isLatin) {
                    span.classList.add('clickable');
                    if (translations[cleanLine]) {
                        span.setAttribute('data-translation', translations[cleanLine]);
                    } else {
                        span.setAttribute('data-translation', "No translation available");
                    }
                }

                wrapper.appendChild(span);
                lyricsContainer.appendChild(wrapper);
                lineElements.push(span);
            });

            let currentIndex = 0;
            // Filter lineElements to only those with a data-start (recognized words)
            const timedLines = lineElements
                .map((el, i) => ({el, i, start: parseFloat(el.getAttribute('data-start'))}))
                .filter(item => !isNaN(item.start))
                .sort((a,b) => a.start - b.start);

            audio.addEventListener('timeupdate', () => {
                const currentTime = audio.currentTime;
                while (currentIndex < timedLines.length && currentTime >= timedLines[currentIndex].start) {
                    timedLines[currentIndex].el.classList.add('highlight');
                    timedLines[currentIndex].el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    if (currentIndex > 0) {
                        timedLines[currentIndex - 1].el.classList.remove('highlight');
                    }
                    currentIndex++;
                }
            });
        });

    // Tooltip logic
    document.addEventListener('click', (event) => {
        if (event.target.classList.contains('clickable')) {
            const translation = event.target.getAttribute('data-translation');
            tooltip.textContent = translation;
            tooltip.style.display = 'block';
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = rect.left + window.scrollX + 'px';
            tooltip.style.top = rect.bottom + window.scrollY + 5 + 'px';
        } else if (tooltip.style.display === 'block') {
            tooltip.style.display = 'none';
        }
    });
});
</script>

</body>
</html>
